diff --git a/Makefile b/Makefile
index 911dd8d..4cc1ba3 100644
--- a/Makefile
+++ b/Makefile
@@ -182,6 +182,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_lsnd\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -251,7 +252,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
+	printf.c umalloc.c lsnd.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
diff --git a/defs.h b/defs.h
index 528b359..2b7f81f 100644
--- a/defs.h
+++ b/defs.h
@@ -33,6 +33,8 @@ void            fileinit(void);
 int             fileread(struct file*, char*, int n);
 int             filestat(struct file*, struct stat*);
 int             filewrite(struct file*, char*, int n);
+//aviv
+int             get_filestat_params(char*);
 
 // fs.c
 void            readsb(int dev, struct superblock *sb);
@@ -52,11 +54,15 @@ struct inode*   nameiparent(char*, char*);
 int             readi(struct inode*, char*, uint, uint);
 void            stati(struct inode*, struct stat*);
 int             writei(struct inode*, char*, uint, uint);
-
+//aviv
+void            find_open_inode(int*);
+int             get_inode_params(char* , int);
 // ide.c
 void            ideinit(void);
 void            ideintr(void);
 void            iderw(struct buf*);
+//aviv 
+int             get_ide_params(char*);
 
 // ioapic.c
 void            ioapicenable(int irq, int cpu);
@@ -120,7 +126,9 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
-
+//aviv
+void            help_acquire(void);
+void            help_release(void);
 // procfs.c
 void            procfsinit(void);
 
@@ -150,6 +158,8 @@ char*           safestrcpy(char*, const char*, int);
 int             strlen(const char*);
 int             strncmp(const char*, const char*, uint);
 char*           strncpy(char*, const char*, int);
+//aviv
+void            itoa(int , char *);
 
 // syscall.c
 int             argint(int, int*);
diff --git a/file.c b/file.c
index 24b32c2..e217157 100644
--- a/file.c
+++ b/file.c
@@ -155,3 +155,60 @@ filewrite(struct file *f, char *addr, int n)
   panic("filewrite");
 }
 
+
+
+int
+get_filestat_params(char* buf){
+  uint free_fds = 0;
+  uint used_fds = 0;
+  uint number_of_refs = 0;
+  uint unique_inode_fds = 0;
+  uint writeable_fds = 0;
+  uint readable_fds = 0;
+  uint refs_per_fds = 0;
+  int inodes_found[NINODE];
+  int found = 0;
+  int i;
+  struct file *f;
+  memset(inodes_found, 0 , NINODE);
+  acquire(&ftable.lock);
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+    found = 0;
+    if(f->ref == 0){
+      free_fds++;
+    }else{
+      used_fds++;
+      if(f->writable){
+        writeable_fds++;
+      }
+      if(f->readable){
+        readable_fds++;
+      }
+      for(i = 0 ; inodes_found[i] ; i ++ ){
+        if(inodes_found[i] == f->ip->inum){
+          found = 1;
+        }
+      }
+      if(!found){
+        unique_inode_fds += 1;
+        inodes_found[i] = f->ip->inum;
+      }
+      number_of_refs += f->ref;
+      
+    }
+  }
+  release(&ftable.lock);
+  strncpy(buf, "Free fds: ", strlen("Free fds: "));
+  itoa(free_fds, buf + strlen(buf));
+  strncpy(buf + strlen(buf), "\nUnique inode fds: ", strlen("\nUnique inode fds:  "));
+  itoa(unique_inode_fds, buf + strlen(buf));
+  strncpy(buf + strlen(buf), "\nWriteable fds: ", strlen("\nWriteable fds:  "));
+  itoa(writeable_fds, buf + strlen(buf));
+  strncpy(buf + strlen(buf), "\nReadable fds: ", strlen("\nReadable fds:  "));
+  itoa(readable_fds, buf + strlen(buf));
+  refs_per_fds = number_of_refs/used_fds;
+  strncpy(buf + strlen(buf), "\nRefs per fds: ", strlen("\nRefs per fds:  "));
+  itoa(refs_per_fds, buf + strlen(buf));
+  strncpy(buf + strlen(buf), "\n", strlen("\n"));
+  return strlen(buf);
+}
\ No newline at end of file
diff --git a/fs.c b/fs.c
index 870d7bf..b86b6b2 100644
--- a/fs.c
+++ b/fs.c
@@ -169,6 +169,12 @@ struct {
   struct inode inode[NINODE];
 } icache;
 
+static char *ip_types[] = {
+    [T_DIR]  "DIR",
+    [T_FILE] "FILE",
+    [T_DEV]  "DEV "
+};
+
 void
 iinit(int dev)
 {
@@ -252,6 +258,7 @@ iget(uint dev, uint inum)
     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
       ip->ref++;
       release(&icache.lock);
+      // cprintf("at iget inum = %d \n", ip->inum);
       return ip;
     }
     if(empty == 0 && ip->ref == 0)    // Remember empty slot.
@@ -529,15 +536,17 @@ dirlookup(struct inode *dp, char *name, uint *poff)
   struct dirent de;
   struct inode *ip;
 
+
   if(dp->type != T_DIR && !IS_DEV_DIR(dp))
     panic("dirlookup not DIR");
-
   for(off = 0; off < dp->size || dp->type == T_DEV ; off += sizeof(de)){
+  //for(off = 0; off < dp->size; off += sizeof(de)){
     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de)) {
       if (dp->type == T_DEV)
         return 0;
       panic("dirlookup read");
     }
+    // cprintf("%s inum = %d \n", de.name, de.inum);
     if(de.inum == 0)
       continue;
     if(namecmp(name, de.name) == 0){
@@ -545,7 +554,12 @@ dirlookup(struct inode *dp, char *name, uint *poff)
       if(poff)
         *poff = off;
       inum = de.inum;
-      ip = iget(dp->dev, inum);
+      // if(dp->inum == 18){
+        // cprintf("%s inum = %d \n", name, dp->inum);
+        // ip = iget(2, inum);  
+      // }else {
+        ip = iget(dp->dev, inum);
+      // }
       if (ip->valid == 0 && dp->type == T_DEV && devsw[dp->major].iread) {
         devsw[dp->major].iread(dp, ip);
       }
@@ -677,3 +691,64 @@ nameiparent(char *path, char *name)
 {
   return namex(path, 1, name);
 }
+
+
+void 
+find_open_inode(int *open_inodes){
+    int j = 0;
+    for (int i = 0 ; i < NINODE ; i++){
+        if(icache.inode[i].ref != 0){
+            open_inodes[j] = i + 1;
+            j++;
+        }
+    }
+}
+
+int
+get_inode_params(char* buf , int inode_index){
+  struct inode * ip = &icache.inode[inode_index];
+  int used_blocks = 0;
+  int i;
+  int j;
+  uint *indirect_blocks;
+  struct buf *indirect_buffer;
+  if(ip->type != T_DEV){
+    for(i = 0; i < NDIRECT; i++){
+      if(ip->addrs[i] != 0){
+        used_blocks += 1;
+      } 
+    }
+    if(ip->addrs[NDIRECT] != 0){
+      indirect_buffer = bread(ip->dev, ip->addrs[NDIRECT]);
+      indirect_blocks = (uint*)indirect_buffer->data;
+      for(j = 0; j < NINDIRECT; j++){
+        if(indirect_blocks[j] != 0){
+          used_blocks += 1;
+        }
+      }
+    }
+  }
+  strncpy(buf, "Device: ", strlen("Device: "));
+  itoa(ip->dev, buf + strlen(buf));
+  strncpy(buf + strlen(buf), "\nInode number: ", strlen("\nInode number: "));
+  itoa(ip->inum, buf + strlen(buf));
+  strncpy(buf + strlen(buf), "\nis valid: ", strlen("\nis valid: "));
+  itoa(ip->valid, buf + strlen(buf));
+  strncpy(buf + strlen(buf), "\ntype: ", strlen("\ntype: "));
+  strncpy(buf + strlen(buf), ip_types[ip->type], strlen(ip_types[ip->type]));
+  strncpy(buf + strlen(buf), "\nmajor minor: (", strlen("\nmajor minor: ("));
+  itoa(ip->major, buf + strlen(buf));
+  strncpy(buf + strlen(buf), ",", strlen(","));
+  itoa(ip->minor, buf + strlen(buf));
+  strncpy(buf + strlen(buf), ")", strlen(")"));
+  strncpy(buf + strlen(buf), "\nhard links: ", strlen("\nhard links: "));
+  itoa(ip->nlink, buf + strlen(buf));
+  strncpy(buf + strlen(buf), "\nblocks used: ", strlen("\nblocks used: "));
+  itoa(used_blocks, buf + strlen(buf));
+  //finish it sucker
+  strncpy(buf + strlen(buf), "\n", strlen("\n"));
+  return strlen(buf);
+}
+
+
+
diff --git a/ide.c b/ide.c
index b4c0b1f..7d49de1 100644
--- a/ide.c
+++ b/ide.c
@@ -166,3 +166,46 @@ iderw(struct buf *b)
 
   release(&idelock);
 }
+
+
+
+
+
+//aviv
+
+int
+get_ide_params(char* buf){
+  // struct buf **pp;
+  struct buf *b;
+  int read_num = 0;
+  int write_num = 0;
+  int total_num = 0;
+  char working_blocks[PGSIZE];
+  memset(working_blocks, '\0' , PGSIZE);
+  // working_blocks[0] = 0;
+  acquire(&idelock);  //DOC:acquire-lock
+  for(b=idequeue; b; b= b->qnext){  //DOC:insert-queue
+    strncpy(working_blocks + strlen(working_blocks), "(", strlen("("));
+    itoa(b->dev, working_blocks + strlen(working_blocks));
+    strncpy(working_blocks + strlen(working_blocks), ",", strlen(","));
+    itoa(b->blockno, working_blocks + strlen(working_blocks));
+    strncpy(working_blocks + strlen(working_blocks), ");", strlen(");"));
+    total_num++;
+    if(b->flags & B_VALID){
+      read_num++;
+    }
+    if(b->flags & B_DIRTY){
+      write_num++;
+    }
+  }
+  strncpy(buf, "waiting operations: ", strlen("waiting operations:  "));
+  itoa(total_num, buf + strlen(buf));
+  strncpy(buf + strlen(buf), "\nread operations: ", strlen("\nread operations:  "));
+  itoa(read_num, buf + strlen(buf));
+  strncpy(buf + strlen(buf), "\nwrite operations: ", strlen("\nwrite operations:  "));
+  itoa(write_num, buf + strlen(buf));
+  strncpy(buf + strlen(buf), "\n", strlen("\n"));
+  strncpy(buf + strlen(buf), working_blocks, strlen(working_blocks));
+  release(&idelock);
+  return strlen(buf);
+}
\ No newline at end of file
diff --git a/init.c b/init.c
index 095275a..feef576 100644
--- a/init.c
+++ b/init.c
@@ -11,14 +11,14 @@ int
 main(void)
 {
   int pid, wpid;
- 
+ //FIXME aviv
   mknod("/proc", 2, 0);
 
   if(open("/console", O_RDWR) < 0){
     mknod("/console", 1, 1);
     open("/console", O_RDWR);
   }
-  
+  // open("/proc/moshe", O_RDONLY);
   dup(0);  // stdout
   dup(0);  // stderr
 
diff --git a/ls.c b/ls.c
index c76187e..d23fc65 100644
--- a/ls.c
+++ b/ls.c
@@ -45,9 +45,9 @@ ls(char *path)
   case T_FILE:
     printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
     break;
-
-  case T_DIR:
+    
   case T_DEV:
+  case T_DIR:
     if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
       printf(1, "ls: path too long\n");
       break;
diff --git a/lsnd.c b/lsnd.c
new file mode 100644
index 0000000..d59c2f0
--- /dev/null
+++ b/lsnd.c
@@ -0,0 +1,56 @@
+#include "types.h"
+#include "user.h"
+#include "fcntl.h"
+
+int
+main(void){
+    char help_buffer[600];
+    char print_buffer[600];
+    int fd;
+    int j;
+    int offset;
+    char* path = "proc/inodeinfo/\0\0\0\0\0";
+    for(int i=0; i<50; i++){
+        memset(help_buffer , 0 , 600);
+        memset(print_buffer , 0 , 600);
+        offset = 0;
+        if(i < 10){
+            path[15] = '0' + i;
+        }else{
+            path[15] = '0' + i/10;
+            path[16] = '0' + i%10;
+        }
+        if((fd = open(path, 0)) < 0){
+        }else{
+            if(read(fd, help_buffer, sizeof(help_buffer)) <= 0){
+               printf(2, "lsnd: cannot read \n");
+                exit();
+            }
+            close(fd);
+            for(j = 0 ; j < strlen(help_buffer) ; j ++){
+                if((help_buffer[j] >= '0') && (help_buffer[j] <= '9')){
+                    print_buffer[offset] = help_buffer[j];
+                    offset++;
+                }else if((help_buffer[j] >= 'A') && (help_buffer[j] <= 'Z')){
+                    print_buffer[offset] = help_buffer[j];
+                    offset++;
+                }else if(help_buffer[j] == '\n'){
+                    print_buffer[offset] = ' ';
+                    offset++;
+                }else if((help_buffer[j] == '(') || (help_buffer[j] == ')') || (help_buffer[j] == ',')){
+                    print_buffer[offset] = help_buffer[j];
+                    offset++;
+                }                  
+            }
+            print_buffer[0] = print_buffer[1];
+            print_buffer[1] = print_buffer[2];
+            for(j =  4; j < strlen(print_buffer) ; j++){
+                print_buffer[j-2] = print_buffer[j];
+            }
+            print_buffer[j-2] = '\0';
+            print_buffer[j-1] = '\0';
+            printf(0, "%s\n", print_buffer);
+        }
+    }
+    exit();
+}
diff --git a/proc.c b/proc.c
index 806b1b1..c8f1ceb 100644
--- a/proc.c
+++ b/proc.c
@@ -496,6 +496,17 @@ kill(int pid)
   return -1;
 }
 
+
+//aviv
+
+void
+help_acquire(){
+  acquire(&ptable.lock);
+}
+void
+help_release(){
+  release(&ptable.lock);
+}
 //PAGEBREAK: 36
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
diff --git a/procfs.c b/procfs.c
index 8cb06cc..2f2b5c6 100644
--- a/procfs.c
+++ b/procfs.c
@@ -12,18 +12,108 @@
 #include "proc.h"
 #include "x86.h"
 
+#define DESZ sizeof(struct dirent)
+#define MAX_BUF (5 + NPROC) * DESZ
+#define min(a, b) ((a) < (b) ? (a) : (b))
+
+extern struct {
+  struct spinlock lock;
+  struct proc proc[NPROC];
+} ptable;
+
+int make_proc(int inum, char *buf);
+int make_Pid(int inum, char *buf);
+char* state_to_str(struct proc *p);
+int get_name(int inum, char *buf);
+int get_status(int inum , char *buf);
+int get_ide_info(int inum , char *buf);
+int get_filestat(int inum , char *buf);
+int make_inodeinfo(int inum , char *buf);
+int get_inode(int inum , char *buf);
+
 int 
 procfsisdir(struct inode *ip) {
+  // cprintf("dir wanted is: %d\n",ip->inum);
+  //if we are at proc / pid / indoeinfo, then this is a directory
+  if(ip->inum == namei("/proc")->inum){
+    return 1;
+  }
+  if((ip->inum % 500 == 0) || (ip->inum == 19) || (ip->inum == 440)){
+    return 1;
+  }
+  // return (ip->minor == T_DIR);
   return 0;
 }
 
 void 
 procfsiread(struct inode* dp, struct inode *ip) {
+  ip->major = PROCFS;
+  ip->type = T_DEV;
+  ip->valid = 1;
+  ip->nlink = 1;
+  if(ip->inum == namei("/proc")->inum){
+    ip->minor = T_DIR;
+  }else if((ip->inum % 500 == 0) || (ip->inum == 19) || (ip->inum == 440)){
+    ip->minor = T_DIR;
+  }else{
+    ip->minor = T_FILE;
+  }
 }
 
 int
 procfsread(struct inode *ip, char *dst, int off, int n) {
-  return 0;
+  // here we should be able to know we have proc, and make the dirents list.....
+  // make at proc struct of max number of procceses dirents, + 1/2
+  int case_number = (ip->inum % 500);
+  int size = 0;
+  // int size_helper;
+  char buffer[MAX_BUF];
+  memset(buffer , 0 , MAX_BUF);
+  if(case_number == namei("/proc")->inum){
+    size = make_proc(ip->inum , buffer);
+  }else{
+    switch (case_number)
+    {
+      // case 19:
+      //   size = make_proc(ip->inum , buffer);
+      // break;
+      case 0: //PID
+        size = make_Pid(ip->inum, buffer);
+      break;
+      case 10: //name
+        size = get_name(ip->inum , buffer);
+      break;
+      case 20: //status
+        size = get_status(ip->inum , buffer);
+      break;
+      case 420: //ideinfo
+        size = get_ide_info(ip->inum, buffer);
+      break;
+      case 430: //filestat
+        size = get_filestat(ip->inum, buffer);
+      break;
+      case 440: //inodeinfo
+        size = make_inodeinfo(ip->inum , buffer);
+      break;
+      default:
+          if((case_number > 440) && (case_number < 500)){
+            size = get_inode(ip->inum, buffer);
+          }
+      break;
+      }
+  }
+  // cprintf("at procfsread inum = %d \n", ip->inum);
+  // if (off < size) {
+  //   size_helper = size - off;
+  //   if(n < size_helper) {
+  //     size_helper = n;
+  //   }
+  //   memmove(dst, buffer + off, size_helper);
+  //   return size_helper;
+  // }
+  // return 0;
+  memmove(dst, buffer + off, n);
+  return min(n , size - off);
 }
 
 int
@@ -40,3 +130,223 @@ procfsinit(void)
   devsw[PROCFS].write = procfswrite;
   devsw[PROCFS].read = procfsread;
 }
+
+
+
+int
+make_proc(int inum , char *buf){
+  int offset = 0;
+  struct dirent de;
+  struct proc *p;
+  char pid_buf[20];
+  // add to the proc: "."
+  de.inum = inum;
+  strncpy(de.name, ".\0", DIRSIZ);
+  memmove(buf + (DESZ * offset), (char *)&de, DESZ);
+  offset++;
+  // add to the proc: ".."
+  de.inum = 1;
+  strncpy(de.name, "..\0", DIRSIZ);
+  memmove(buf + (DESZ * offset), (char *)&de, DESZ);
+  offset++;
+  // add to the proc: "ideinfo"
+  de.inum = 420;
+  strncpy(de.name, "ideinfo\0", DIRSIZ);
+  memmove(buf + (DESZ * offset), (char *)&de, DESZ);
+  offset++;
+  //add to the proc: "filestat"
+  de.inum = 430;
+  strncpy(de.name, "filestat\0", DIRSIZ);
+  memmove(buf + (DESZ * offset) , (char *)&de, DESZ);
+  offset++;
+  //add to the proc: "inodeinfo"
+  de.inum = 440;
+  strncpy(de.name, "inodeinfo\0", DIRSIZ);
+  memmove(buf + (DESZ * offset) , (char *)&de, DESZ);
+  offset++;
+  help_acquire();
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED )
+    continue;
+    else {
+      de.inum = 500 *  p->pid;
+      itoa(p->pid, pid_buf);
+      strncpy(de.name, pid_buf, DIRSIZ);
+      memmove(buf + (DESZ * offset), (char *)&de, DESZ);
+      offset++;
+    }
+  }
+  help_release();
+  return (DESZ * offset);
+}
+
+int
+make_Pid(int inum, char *buf) {
+  // struct proc *p;
+  struct dirent de;
+  int offset = 0;
+  //the . is the pid dir, .. is proc, name, and status files
+  de.inum = inum;
+  strncpy(de.name, ".\0", DIRSIZ);
+  memmove(buf + (DESZ * offset), (char *)&de, DESZ);
+  offset++;
+  // de.inum = 19;
+  de.inum = namei("/proc")->inum;
+  strncpy(de.name, "..\0", DIRSIZ);
+  memmove(buf + (DESZ * offset), (char *)&de, DESZ);
+  offset++;
+  de.inum = 10 + inum;
+  strncpy(de.name, "name\0", DIRSIZ);
+  memmove(buf + (DESZ * offset), (char *)&de, DESZ);
+  offset++;
+  de.inum = 20 + inum;
+  strncpy(de.name, "status\0", DIRSIZ);
+  memmove(buf + (DESZ * offset), (char *)&de, DESZ);
+  offset++;
+
+  return (DESZ * offset);
+}
+
+int
+get_status(int inum , char *buf){
+  //they want to read status so we need to make the file with the right status
+  struct proc *p;
+  struct proc *wanted = 0;
+  int found = 0;
+  //dir inum is pid*500+20
+  int wanted_pid = (inum - 20)/500;
+  char* procstat;
+  char sz[20];
+  //catch ptable lock so no proc will change its stat or sz in middle
+  //then iterate over ptable to find wanted proc....
+  help_acquire();
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED )
+    continue;
+    else {
+      if(p->pid == wanted_pid){
+        wanted = p;
+        found = 1;
+      }
+    }
+  }
+  help_release();
+  if(!found){
+    panic("possible not to find pid when look for status?");
+  }
+  procstat = state_to_str(wanted);
+  itoa(wanted->sz, sz);
+  strncpy(buf, "state: ", strlen("state:  "));
+  strncpy(buf + strlen(buf),procstat, strlen(procstat) + 1);
+  strncpy(buf + strlen(buf), " Size: ", strlen(" Size:  "));
+  strncpy(buf + strlen(buf), sz, strlen(sz)+1);
+  strncpy(buf + strlen(buf), "\n", strlen("\n") + 1);
+  return strlen(buf);
+}
+
+char*
+state_to_str(struct proc *p){
+   switch(p->state){
+    case UNUSED:
+    return "UNUSED";
+    break;
+    case EMBRYO:
+    return "EMBRYO";
+    break;
+    case SLEEPING:
+    return "SLEEPING";
+    break;
+    case RUNNABLE:
+    return "RUNNABLE";
+    break;
+    case RUNNING:
+    return "RUNNING";
+    break;
+    case ZOMBIE:
+    return "ZOMBIE";
+    break;
+    default:
+    return "impossible";
+  }
+}
+
+int
+get_ide_info(int inum , char *buf){
+  int size = 0;
+  //aviv
+  size = get_ide_params(buf);
+  return size;
+}
+
+int
+get_name(int inum , char *buf){
+  struct proc *p;
+  struct proc *wanted = 0;
+  int found = 0;
+  int wanted_pid = (inum - 10)/500;
+  help_acquire();
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED )
+    continue;
+    else {
+      if(p->pid == wanted_pid){
+        wanted = p;
+        found = 1;
+      }
+    }
+  }
+  help_release();
+  if(!found){
+    panic("possible not to find pidwhen look for name?");
+  }
+  strncpy(buf, wanted->name, strlen(wanted->name));
+  strncpy(buf + strlen(buf), "\n", strlen("\n"));
+  return strlen(buf);
+}
+
+int
+get_filestat(int inum , char *buf){
+  int size = 0;
+  //aviv
+  size = get_filestat_params(buf);
+  return size;
+}
+
+
+int
+make_inodeinfo(int inum , char *buf){
+  struct dirent de;
+  int offset = 0;
+  int open_inodes[NINODE];
+  int i = 0;
+  char inode_buf[20];
+  memset(open_inodes , 0 , NINODE);
+  de.inum = inum;
+  strncpy(de.name, ".\0", DIRSIZ);
+  memmove(buf + (DESZ * offset), (char *)&de, DESZ);
+  offset++;
+  // de.inum = 19;
+  de.inum = namei("/proc")->inum;
+  strncpy(de.name, "..\0", DIRSIZ);
+  memmove(buf + (DESZ * offset), (char *)&de, DESZ);
+  offset++;
+  find_open_inode(open_inodes);
+  for(i = 0; open_inodes[i]; i++){
+      de.inum = inum + open_inodes[i] + 1;
+      itoa(open_inodes[i] - 1, inode_buf);
+      strncpy(de.name, inode_buf, DIRSIZ);
+      memmove(buf + (DESZ * offset), (char *)&de, DESZ);
+      offset++;
+  }
+  return (DESZ * offset);
+}
+
+int
+get_inode(int inum , char *buf){
+  int size = 0;
+  //aviv
+  int inode_index = inum - 2 - 440;
+  // cprintf("inum is %d , %d \n", inum, inode_index);
+  size = get_inode_params(buf , inode_index);
+  return size;
+}
\ No newline at end of file
diff --git a/string.c b/string.c
index a7cc61f..6669039 100644
--- a/string.c
+++ b/string.c
@@ -103,3 +103,21 @@ strlen(const char *s)
   return n;
 }
 
+
+void
+itoa(int num, char *buf){
+  static char digits[] = "0123456789";
+  int i = 0;
+  char tmp;
+
+  do{
+    buf[i++] = digits[num % 10];
+  }while((num /= 10) != 0);
+  buf[i] = '\0';
+
+  for (i = 0; i < strlen(buf) / 2; i++){
+    tmp = buf[i];
+    buf[i] = buf[strlen(buf) - i - 1];
+    buf[strlen(buf) - i - 1] = tmp;
+  }
+}
\ No newline at end of file
diff --git a/sysfile.c b/sysfile.c
index 87e508b..c5cf687 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -382,7 +382,7 @@ sys_chdir(void)
     return -1;
   }
   ilock(ip);
-  if(ip->type != T_DIR){
+  if((ip->type != T_DIR) && (!IS_DEV_DIR(ip))){
     iunlockput(ip);
     end_op();
     return -1;
